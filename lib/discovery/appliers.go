package discovery

import (
	pb_resolvers "github.com/mwitkow/kedge/_protogen/kedge/config/common/resolvers"
	pb_grpcbackends "github.com/mwitkow/kedge/_protogen/kedge/config/grpc/backends"
	pb_grpcroutes "github.com/mwitkow/kedge/_protogen/kedge/config/grpc/routes"
	pb_httpbackends "github.com/mwitkow/kedge/_protogen/kedge/config/http/backends"
	pb_httproutes "github.com/mwitkow/kedge/_protogen/kedge/config/http/routes"
)

func (u *updater) applyHTTPRouteToDirector(backendName string, oldRoutes []route, newRoutes []route) {
	for _, oldRoute := range oldRoutes {
		toDeleteIndex := -1
		for i, directorRoute := range u.currentDirectorConfig.GetHttp().Routes {
			if !directorRoute.Autogenerated {
				// Do not modify not generated ones.
				continue
			}

			if directorRoute.HostMatcher == oldRoute.nameMatcher &&
				directorRoute.PortMatcher == oldRoute.portMatcher {
				toDeleteIndex = i
				break
			}
		}

		if toDeleteIndex >= 0 {
			u.currentDirectorConfig.GetHttp().Routes = append(
				u.currentDirectorConfig.GetHttp().Routes[:toDeleteIndex],
				u.currentDirectorConfig.GetHttp().Routes[toDeleteIndex+1:]...,
			)
		}
	}

	for _, newRoute := range newRoutes {
		u.currentDirectorConfig.GetHttp().Routes = append(
			u.currentDirectorConfig.GetHttp().Routes,
			&pb_httproutes.Route{
				Autogenerated: true,
				BackendName:   backendName,
				HostMatcher:   newRoute.nameMatcher,
				PortMatcher:   newRoute.portMatcher,
				ProxyMode:     pb_httproutes.ProxyMode_REVERSE_PROXY,
			},
		)
	}
}

func (u *updater) applyHTTPRouteToBackendpool(backendName backendName, domainPortPerBackend map[backendName]string) {
	toDeleteIndex := -1
	for i, b := range u.currentBackendConfig.GetHttp().Backends {
		if !b.Autogenerated {
			// Do not modify not generated ones.
			continue
		}

		if b.Name == backendName.String() {
			toDeleteIndex = i
			break
		}
	}

	if toDeleteIndex >= 0 {
		u.currentBackendConfig.GetHttp().Backends = append(
			u.currentBackendConfig.GetHttp().Backends[:toDeleteIndex],
			u.currentBackendConfig.GetHttp().Backends[toDeleteIndex+1:]...,
		)
	}

	if domainPort, ok := domainPortPerBackend[backendName]; ok {
		u.currentBackendConfig.GetHttp().Backends = append(
			u.currentBackendConfig.GetHttp().Backends,
			&pb_httpbackends.Backend{
				Autogenerated: true,
				Name:          backendName.String(),
				Resolver: &pb_httpbackends.Backend_K8S{
					K8S: &pb_resolvers.K8SResolver{
						DnsPortName: domainPort,
					},
				},
				Balancer: pb_httpbackends.Balancer_ROUND_ROBIN,
			},
		)
	}
}

func (u *updater) applygRPCRouteToDirector(backendName string, oldRoutes []route, newRoutes []route) {
	for _, oldRoute := range oldRoutes {
		toDeleteIndex := -1
		for i, directorRoute := range u.currentDirectorConfig.GetGrpc().Routes {
			if !directorRoute.Autogenerated {
				// Do not modify not generated ones.
				continue
			}

			if directorRoute.ServiceNameMatcher == oldRoute.nameMatcher &&
				directorRoute.PortMatcher == oldRoute.portMatcher {
				toDeleteIndex = i
				break
			}
		}

		if toDeleteIndex >= 0 {
			u.currentDirectorConfig.GetGrpc().Routes = append(
				u.currentDirectorConfig.GetGrpc().Routes[:toDeleteIndex],
				u.currentDirectorConfig.GetGrpc().Routes[toDeleteIndex+1:]...,
			)
		}
	}

	for _, newRoute := range newRoutes {
		u.currentDirectorConfig.GetGrpc().Routes = append(
			u.currentDirectorConfig.GetGrpc().Routes,
			&pb_grpcroutes.Route{
				Autogenerated:      true,
				BackendName:        backendName,
				ServiceNameMatcher: newRoute.nameMatcher,
				PortMatcher:        newRoute.portMatcher,
			},
		)
	}
}

func (u *updater) applygRPCRouteToBackendpool(backendName backendName, domainPortPerBackend map[backendName]string) {
	toDeleteIndex := -1
	for i, backends := range u.currentBackendConfig.GetGrpc().Backends {
		if !backends.Autogenerated {
			// Do not modify not generated ones.
			continue
		}

		if backends.Name == backendName.String() {
			toDeleteIndex = i
			break
		}
	}

	if toDeleteIndex >= 0 {
		u.currentBackendConfig.GetGrpc().Backends = append(
			u.currentBackendConfig.GetGrpc().Backends[:toDeleteIndex],
			u.currentBackendConfig.GetGrpc().Backends[toDeleteIndex+1:]...,
		)
	}

	if domainPort, ok := domainPortPerBackend[backendName]; ok {
		u.currentBackendConfig.GetGrpc().Backends = append(
			u.currentBackendConfig.GetGrpc().Backends,
			&pb_grpcbackends.Backend{
				Autogenerated: true,
				Name:          backendName.String(),
				Resolver: &pb_grpcbackends.Backend_K8S{
					K8S: &pb_resolvers.K8SResolver{
						DnsPortName: domainPort,
					},
				},
				Balancer: pb_grpcbackends.Balancer_ROUND_ROBIN,
			},
		)
	}
}
