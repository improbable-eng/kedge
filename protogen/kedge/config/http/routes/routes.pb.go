// Code generated by protoc-gen-go. DO NOT EDIT.
// source: kedge/config/http/routes/routes.proto

package kedge_config_http_routes

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/mwitkow/go-proto-validators"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ProxyMode int32

const (
	ProxyMode_ANY ProxyMode = 0
	// / Reverse Proxy is when the FE serves an authority (Host) publicly and clients connect to that authority
	// / directly. This is used to expose publicly DNS-resolvable names.
	ProxyMode_REVERSE_PROXY ProxyMode = 1
	// / Forward Proxy is when the FE serves as an HTTP_PROXY for a browser or an application. The resolution of the
	// / backend is done by the FE itself, so non-public names can be addressed.
	// / This may be from the 90s, but it still is very useful.
	// /
	// / IMPORTANT: If you have a PAC file configured in Firefox, the HTTPS rule behaves differently than in Chrome. The
	// / proxied requests are not FORWARD_PROXY requests but REVERSE_PROXY_REQUESTS.
	ProxyMode_FORWARD_PROXY ProxyMode = 2
)

var ProxyMode_name = map[int32]string{
	0: "ANY",
	1: "REVERSE_PROXY",
	2: "FORWARD_PROXY",
}
var ProxyMode_value = map[string]int32{
	"ANY":           0,
	"REVERSE_PROXY": 1,
	"FORWARD_PROXY": 2,
}

func (x ProxyMode) String() string {
	return proto.EnumName(ProxyMode_name, int32(x))
}
func (ProxyMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

// / Route describes a mapping between a stable proxying endpoint and a pre-defined backend.
type Route struct {
	// / backend_name is the string identifying the HTTP backend pool to send data to.
	BackendName string `protobuf:"bytes,1,opt,name=backend_name,json=backendName" json:"backend_name,omitempty"`
	// / path_rules is a globbing expression that matches a URL path of the request.
	// / See: https://cloud.google.com/compute/docs/load-balancing/http/url-map
	// / If not present, '/*' is default.
	PathRules []string `protobuf:"bytes,2,rep,name=path_rules,json=pathRules" json:"path_rules,omitempty"`
	// / host_matcher matches on the ':authority' header (a.k.a. Host header) enabling Virtual Host-like proxying.
	// / The matching is done through lower-case string-equality.
	// / If none are present, the route skips ':authority' checks.
	HostMatcher string `protobuf:"bytes,3,opt,name=host_matcher,json=hostMatcher" json:"host_matcher,omitempty"`
	// / metadata_matcher matches any HTTP inbound request Headers.
	// / Eeach key provided must find a match for the route to match.
	// / The matching is done through lower-case key match and explicit string-equality of values.
	// / If none are present, the route skips metadata checks.
	HeaderMatcher map[string]string `protobuf:"bytes,4,rep,name=header_matcher,json=headerMatcher" json:"header_matcher,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// / proxy_mode controlls what kind of inbound requests this route matches. See
	ProxyMode ProxyMode `protobuf:"varint,5,opt,name=proxy_mode,json=proxyMode,enum=kedge.config.http.routes.ProxyMode" json:"proxy_mode,omitempty"`
	// / Optional port matcher. If 0 route will ignore port.
	// TODO(bplotka): Type is not consistend with authority_host_matcher
	PortMatcher   uint32 `protobuf:"varint,6,opt,name=port_matcher,json=portMatcher" json:"port_matcher,omitempty"`
	Autogenerated bool   `protobuf:"varint,7,opt,name=autogenerated" json:"autogenerated,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *Route) GetBackendName() string {
	if m != nil {
		return m.BackendName
	}
	return ""
}

func (m *Route) GetPathRules() []string {
	if m != nil {
		return m.PathRules
	}
	return nil
}

func (m *Route) GetHostMatcher() string {
	if m != nil {
		return m.HostMatcher
	}
	return ""
}

func (m *Route) GetHeaderMatcher() map[string]string {
	if m != nil {
		return m.HeaderMatcher
	}
	return nil
}

func (m *Route) GetProxyMode() ProxyMode {
	if m != nil {
		return m.ProxyMode
	}
	return ProxyMode_ANY
}

func (m *Route) GetPortMatcher() uint32 {
	if m != nil {
		return m.PortMatcher
	}
	return 0
}

func (m *Route) GetAutogenerated() bool {
	if m != nil {
		return m.Autogenerated
	}
	return false
}

func init() {
	proto.RegisterType((*Route)(nil), "kedge.config.http.routes.Route")
	proto.RegisterEnum("kedge.config.http.routes.ProxyMode", ProxyMode_name, ProxyMode_value)
}

func init() { proto.RegisterFile("kedge/config/http/routes/routes.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 420 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0xdf, 0x6a, 0xd4, 0x40,
	0x14, 0xc6, 0xcd, 0xc6, 0x6d, 0xcd, 0xd9, 0x6e, 0x59, 0x87, 0x5e, 0x0c, 0x05, 0x31, 0x6a, 0x85,
	0x20, 0xee, 0x44, 0x56, 0x29, 0x5a, 0x6f, 0x6c, 0x31, 0xe2, 0x4d, 0xff, 0x30, 0x82, 0xba, 0x88,
	0x86, 0xd9, 0xe4, 0x98, 0x84, 0x6c, 0x32, 0x61, 0x32, 0x69, 0x5d, 0xc5, 0x77, 0xf2, 0x8d, 0x04,
	0x9f, 0x44, 0x26, 0x49, 0x57, 0x45, 0x7a, 0x35, 0x67, 0x7e, 0xf3, 0x9d, 0x6f, 0xce, 0x37, 0x03,
	0xf7, 0x73, 0x8c, 0x13, 0xf4, 0x23, 0x59, 0x7e, 0xce, 0x12, 0x3f, 0xd5, 0xba, 0xf2, 0x95, 0x6c,
	0x34, 0xd6, 0xfd, 0xc2, 0x2a, 0x25, 0xb5, 0x24, 0xb4, 0x95, 0xb1, 0x4e, 0xc6, 0x8c, 0x8c, 0x75,
	0xe7, 0xbb, 0xfb, 0x49, 0xa6, 0xd3, 0x66, 0xc1, 0x22, 0x59, 0xf8, 0xc5, 0x45, 0xa6, 0x73, 0x79,
	0xe1, 0x27, 0x72, 0xda, 0xb6, 0x4d, 0xcf, 0xc5, 0x32, 0x8b, 0x85, 0x96, 0xaa, 0xf6, 0xd7, 0x65,
	0xe7, 0x78, 0xf7, 0x87, 0x0d, 0x43, 0x6e, 0x2c, 0xc8, 0x73, 0xd8, 0x5a, 0x88, 0x28, 0xc7, 0x32,
	0x0e, 0x4b, 0x51, 0x20, 0xb5, 0x5c, 0xcb, 0x73, 0x8e, 0xe8, 0xaf, 0x9f, 0xb7, 0x77, 0x80, 0x7c,
	0xfa, 0x20, 0xa6, 0x5f, 0xc3, 0x47, 0xd3, 0x67, 0xec, 0xe3, 0xb7, 0xd9, 0xc3, 0xfd, 0x27, 0xdf,
	0xf7, 0xf8, 0xa8, 0x57, 0x9f, 0x88, 0x02, 0xc9, 0x2d, 0x80, 0x4a, 0xe8, 0x34, 0x54, 0xcd, 0x12,
	0x6b, 0x3a, 0x70, 0x6d, 0xcf, 0xe1, 0x8e, 0x21, 0xdc, 0x00, 0x72, 0x07, 0xb6, 0x52, 0x59, 0xeb,
	0xb0, 0x10, 0x3a, 0x4a, 0x51, 0x51, 0xdb, 0x78, 0xf3, 0x91, 0x61, 0xc7, 0x1d, 0x22, 0x73, 0xd8,
	0x4e, 0x51, 0xc4, 0xa8, 0xd6, 0xa2, 0xeb, 0xae, 0xed, 0x8d, 0x66, 0x33, 0x76, 0x55, 0x66, 0xd6,
	0xce, 0xcd, 0x5e, 0xb7, 0x5d, 0xbd, 0x4d, 0x50, 0x6a, 0xb5, 0xe2, 0xe3, 0xf4, 0x6f, 0x46, 0x8e,
	0x00, 0x2a, 0x25, 0xbf, 0xac, 0xc2, 0x42, 0xc6, 0x48, 0x87, 0xae, 0xe5, 0x6d, 0xcf, 0xee, 0x5d,
	0x6d, 0x7b, 0x66, 0xb4, 0xc7, 0x32, 0x46, 0xee, 0x54, 0x97, 0xa5, 0x49, 0x50, 0x49, 0xf5, 0x27,
	0xc1, 0x86, 0x6b, 0x79, 0x63, 0x3e, 0x32, 0xec, 0xf2, 0x9a, 0x3d, 0x18, 0x8b, 0x46, 0xcb, 0x04,
	0x4b, 0x54, 0x42, 0x63, 0x4c, 0x37, 0x5d, 0xcb, 0xbb, 0xc1, 0xff, 0x85, 0xbb, 0x2f, 0x80, 0xfc,
	0x3f, 0x31, 0x99, 0x80, 0x9d, 0xe3, 0xaa, 0x7b, 0x73, 0x6e, 0x4a, 0xb2, 0x03, 0xc3, 0x73, 0xb1,
	0x6c, 0x90, 0x0e, 0x5a, 0xd6, 0x6d, 0x0e, 0x06, 0x4f, 0xad, 0x07, 0x07, 0xe0, 0xac, 0x47, 0x24,
	0x9b, 0x60, 0x1f, 0x9e, 0xcc, 0x27, 0xd7, 0xc8, 0x4d, 0x18, 0xf3, 0xe0, 0x6d, 0xc0, 0xdf, 0x04,
	0xe1, 0x19, 0x3f, 0x7d, 0x3f, 0x9f, 0x58, 0x06, 0xbd, 0x3a, 0xe5, 0xef, 0x0e, 0xf9, 0xcb, 0x1e,
	0x0d, 0x16, 0x1b, 0xed, 0xaf, 0x3f, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xee, 0xa4, 0x0f, 0xfb,
	0x70, 0x02, 0x00, 0x00,
}
